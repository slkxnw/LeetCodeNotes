# 动态规划/回溯/记忆化搜索

## 1. 思路

(灵神讲解)[https://www.bilibili.com/video/BV1Xj411K7oF/]

**可能是从后往前的，而非从前往后规划**

## 2. 例题

### 1. 1223-骰子序列

![](pics/动态规划/img-2023-02-10-10-03-39.png)

思路1：

1. 定义状态为d[i][j][k],代表第i次骰子投出j，并且已经连续投掷了k次

2. 结果应为d[n][j =1 ： 6][k = rollMax(j)]的累加和

3. 接下来定义状态转移：对于每个d[i - 1][j = 1 ： 6][k]，枚举可能得到的6个数p，并且根据已经连续投掷的次数k，确定能否为序列添加这个数

如果新的数字p不同于j，可以直接加，也就是d[i][p][1] += d[i - 1][j][k]

如果新的数字p==j，就看k+1是否小于rollmax，小于是：d[i][j][k+1] += d[i - 1][j][k]

思路2：

1. 定义状态为d[i][j],代表第i次骰子投出j的序列个数

2. 结果为d[n][j = 1:6]的累加

3. 接下来确定状态转移：

a.首先：d[i][j]和d[i-1][1]， d[i-1][2]，...d[i-1][6]有关：

可以让dp[i][j] = sum(d[i-1][1]， d[i-1][2]，...d[i-1][6]),这是合理的，但问题是，这里面会有非法的序列，要把他们去掉

b. 然后：d[i][j]的非法序列数目和dp[i-rollMax[0]- 1][1],...,dp[i - rollMax[5] - 1][6]有关

对于a.得到的全部序列，非法序列为j连续的次数**正好等于roolMax[j - 1] + 1**，不会是+2，因为这在i-1的状态中已经被去除

假设，j = 5，最大连续次数为3

也就是说，非法的5结尾的序列的个数为：sum(dp[i-rollMax[4]- 1][1],...,dp[i - rollMax[4] - 1][6]),就是在第i-rollMax[4]- 1次投掷时，
所有投掷结果不为5的序列的个数的和（**非法的序列为，在这些序列后连续投掷3 + 1 次5**）

4. 时间复杂度：O6n，一个大循环n次，每次内部处理1-6的情况
5. 空间复杂度O(7(n+1))，每次循环用一个变量记录增量，加上每次循环中的状态有6个，n+1是因为它的状态不是从0开始的，do[0][:]没有使用，占据了额外空间

# 题目

![](pics/230224-2357/img-2023-02-24-10-38-18.png)

# 思路 

1. 排序后，每一次操作，将最小的元素变为0，也就是减去最小的元素m，直到k次操作后，最大的元素被减到零

    注意，每次减去元素m，是在全数组范围内进行的，也就是说，第一次操作减去m，第二次操作减去的是（原有的数p - m）,第三次减去的是（原有的数q - p)

    这里维护了一个dec，记录当前元素已经被削减的值的大小，实际上，它等于上一个元素的大小，这样对于边界条件好设计，不然，直接减去上一个元素，在开始的时候边界不好设计

2. 注意到，每一次操作，将数组中值为某个大小的元素变为0，因此，数组中不同元素的个数就是最小操作次数

    使用哈希表（unordered_set），统计相同元素的个数，使用set也可以，但是时间用时多：map、multimap、set 和 multiset 等容器在插入时对元素进
行排序，因此其插入速度更慢。查找复杂度也是对数

    哈希表的std::unordered_set 的插入和查找时间几乎是固定的
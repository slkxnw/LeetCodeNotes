# 翻转字符串

1. 直接对调

# 整数翻转

1. 对10取余得到原始数字的最后一位，并直接将原有的res * 10 + 这个最后一位

    如果这样更新后会过界，有 res * 10 + 这个最后一位 > 2^31 - 1

    变形为 res > (2^31 - 1 -  这个最后一位) / 10

# 唯一字符

1. 使用哈希表，记录每个字符最后出现的位置和总共出现的次数，然后遍历哈希表，得到出现位置最早的，出现一次的字符

# 异位字符串

1. 使用哈希表，记录第一个字符串中出现的字符的次数，遍历第二个字符串，减去次数，

# 验证回文串

1. 将不符合要求的字母去掉，并且将大写字母变为小写，然后双指针遍历

2. 也可以直接双指针，但是它的指针跳动的距离就不一定

# 字符串转整数

1. 题目很简单，但是条件很复杂，并且没有说清楚

# 从大字符串找到第一个匹配小字符串的位置

1. 一个指针h1指向大串，一个指向小船h2，在一个循环中，比较指向的值，如果相同，就同时加一，如果不同，**小串指针h2回溯到0，大串指针回溯到h1-h2+1**

    循环退出条件为h1指向了大串末尾

2. KMP算法
    
# 外观序列

1. 细节处理有问题，思路没错

# 链接两字母单词最长回文串

哈希表

注意，要记录出现次数而不是是否出现，相同字符串会出现多次

# 任务调度器

std::greater<int>()降序排列比较函数

贪心算法

优先排雷多的元素，然后将次多/次次多元素插入到空中，最后剩的在左一次排列

这样有问题，

实际上，如果两个相同元素之间的空n大于元素的种类数

那么必然这样拍，先把最多的元素排好，然后在空隙里拍其他元素，最后，最多元素如果不是一个，那就这些元素会各自剩下一个，把他们放到最后

如果如果两个相同元素之间的空n小于元素的种类数，就是tasks长度
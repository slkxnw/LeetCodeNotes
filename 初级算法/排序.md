# 排序方法

# 颜色分类

1. 排序

2. 统计012 个数，然后挨个给原数组赋值

3. 时间On，空间O1的方法

    维护一个pos_Ed重后向前指向，pos_St从前到后指向

    从前到后遍历元素，如果当前元素是2，就和pos_Ed指向的元素交换，pos-ed前移

     如果当前元素是0，就和pos_st指向的元素交换，pos-st后移

    如果当前元素是1，就遍历下一个元素


    这个方法保证pos-ed后面的元素都是2，posst前面的元素都是1

    **注意，当当前指向的元素已经在posed后面的时候，不用进行交换了，直接遍历下一个，当指向元素小于等于posst的时候也一样**

# 前k个高频元素

必须要遍历整个数组才行

vector统计每个元素的数量，然后对vector排序，取前几个

# 第k个元素

时间复杂度On

1. 快慢指针？

委会一个vector

快指针指向最大值，满指针指向第k个大的值

如果不够k个元素，来的新元素会填入vector，并更新快满指针的值

然后

新来的元素，如果小于慢指针，就不管，如果快于慢指针，并且快满指针的差不是k，就填入他们之间

如果差是k，就对中间的元素排序，然后更新慢指针

会超过时间限制，或者我更新一下，把求第k个最大值，改成求第n-k个最小值

这好像就是堆的思想

但是时间复杂度为nKlogk

**这是个高频考题，好好看一下解法**

2. 使用快速排序，不完全排列，当选定一个数，它的右边有k个元素的时候，返回结果

# 寻找峰值

logn的时间复杂度：一定是二分来做

1. 遍历一遍可定可以得出答案，但是On时间复杂度

**如何logn复杂度，看官方**

2. 二分法

首先明确：由于任意两个相邻元素不相等，并且，数列的两端元素取为负无穷，这个数列一定是有峰值的

然后：只要有上坡，就会有峰值：加入一致上坡的两端，两端会是峰值，如果没有一直上坡到两端，在数列中间一定会有峰值

二分，不断缩小有上坡的区间的范围

**注意，边界缩小到mid和mid+1中比较大的一个，只有往上走，才有峰值**

# 排序数组中元素的第一个和最后一个位置

logn时间内:二分法

注意二分法的格式：

l<=r

l = mid+1

r = mid - 1

后面的结果中，如果l>r,说明没有结果，否则，结果为（l + r） / 2

# 合并区间

1. 使用最多流星窗口方法

将区间拆分为起点和终点，并分别重组委【起点， 1】，【终点， -1】，排序，首先按照起点/终点的大小升序排列，某个起点和某个终点位置相同，将起点排在前面（按照1/-1从大到小排列）

然后遍历，使用tmp，记录当前的覆盖情况，经过一个起点tmp + 1，经过一个终点，tmp-1， 如果在经过一个点之前，tmp == 0，就把要经过的点设为区间起点

如果经过一个点后，tmp==0，就把经过的点作为区间终点，

2. 排序，按照首先按照左区间大小排序升序排列，相同时，按照右区间大小升序排列

遍历，如果当前区间的右端点在下一个区间内部，这两个就可以合并

# 搜索旋转数组

logn：二分法

1. 二分法：要用到旋转数组的性质

好像没什么特别的，有的：无法正常二分了，如果目标是最小的值，那么它不在第一个位置上

首先，判断目标在前半段还是后半段：target > nums[0]

如果在前半段，要判断mid是否落在前半段：nums[mid] < nums[nums.size() - 1] && nums[0] > nums[nums.size() - 1

如果没有落在前半段，就把r变成mid - 1

**注意，这里&& nums[0] > nums[nums.size() - 1，以防没有旋转，错误移动了r的值**

如果在前半段，就正常二分

如果在后半段，要潘森mid是否落在后半段：nums[mid] > nums[nums.size() - 1]

如果没有，就把l变成mid+1

如果在了，就二分

# 搜索二维矩阵 II

1. 先搜索行，去掉不可能包含目标的行

2. 在这个基础上搜索列，去掉不可能包含目标的列

3. 重复这个过程，知道只剩下一个元素或者一个都不剩下

太麻烦了

官方：

Z 字查找：

从第一行最后一个元素开始，如果它大于target，就说明它下面的元素权大于target，向左移动

如果当前元素小于target，我们不能向右移动，因为根据分析，右边列所有元素都大于target，应该下移

知道找到target或者超出边界




# 爬楼梯

1. n = i时的爬楼梯方案个数,等于n-1的方案数 + n-2的方案数

# 买卖股票的最佳时机

1. 简单，倒着来，维护从后向前i范围内的最大值，他是，以当前推进到的数为买入日，可以获得最大收益的抛出日

2. dp

前i天的最高收益，是前i-1天的最高收益，和当前价格 - 之前的最低价格，这两个中的较大值，需要维护一个最低价格

# 最大子序列和

以某一个元素为结尾的子序列有很多，计算其中的最大值

比较这些最大值，最大的一个就是结果

以第i个元素结尾的最大值maxi和以第i+1个元素结尾的最大值max_i+1有如下的关系

如果max_i >= 0,max_i+1 = max_i + 第i+1个元素

否则。max_i+1 = 第i+1个元素

根据这个关系，进行动态规划

# 打家劫舍


如果以dp[i][0]表示，偷了第i家的最大金额，dp[i][1]表示，没偷第i加的最大金额

那么dp[i][0] = max(dp[i - 2][0] + m[i], dp[i - 2][1] + m[i], dp[i - 1][1] + m[i])

偷了第i家，要求前一家没有偷，前两家的状况无关，可以偷，也可以不偷，总共三种情况，比较他们的最大值

dp[i][i] = max(dp[i - 2][0], dp[i - 2][1], dp[i - 1][0], dp[i - 1][1], )

没偷第i家，对于前一家，前两家的状况无关，因此比较四种情况的最大值

初始条件为
dp[0][0] = m[0];
dp[0][1] = 0;
dp[1][0] = m[1];
dp[1][1] = m[0];

输出，max(dp[n][0],dp[n][1])

实际上，可以再简化， 不考虑前两家的状况，只考虑前一家的状况

子问题是，从前i个房子中可以偷到的最大值，分为两种情况，偷了第i个房子和没偷第i个房子

从前i-1个房子可以偷到的最大值，依靠，从前i个房子中可以偷到的最大值的两个状态得出

# 爬楼梯的最小花费

1. 到达第i阶梯需要的最小花费，为第i-1阶梯的最小花费+i-1阶梯的花费，和i-2阶梯的最小花费 + i- 2阶梯的花费，中的较小值

    初始条件，到达第0阶梯和第1阶梯的花费为0，

# 打家劫舍2

如果没有第一个，他和传统的打家劫舍是一样的：偷了最后一个就不能偷第一个

如果没有最后一个，他和传统的打家劫舍是一样的：偷了第一个，就不能偷最后一个

搞两次，一个从第二个开始，一个到导数第二个结束，比较他们的最大值

# 删除并获得点数

子问题：删除到第i个大小的数时，可以获得的最大点数

他和前一个数的大小以及是否删除状态有关

如果主动删除第i个数，那么如果前一个数和它不相邻，那就没关系，最大值，就是前一个数删除/不删除的最大值加上删除当前的得分

如果前一个数和它相邻，是不删除前一个的最大值 + 删除当前的得分

如果不主动删除第i个数，如果前一个数和他相邻，最大值就是前一个数主动删除/不主动删除的最大值

如果前一个数不和他相邻，最大值就是前一个数主动删除/不主动删除的最大值

**将每个值可以得到的点数计算出来后，这就是一个打家劫舍**

# 跳跃游戏

跳跃能否覆盖整个数组

前i个数能否被覆盖和前i-1个数能否被覆盖有关

覆盖前i个数，一定会把第i-1个数也覆盖掉，但是他们支架有什么关系呢？

**可以统计，经过i的，可以覆盖最远的距离**

i的这个值，和i-1的这个值有关系，如果，第i-1个跳跃的值，超过，i-1的这个值，那么，i的这个值为第i-1个跳跃的值覆盖到的地方

失败的条件为，某一个值的最远覆盖小于这个值的位置

# 跳跃游戏2

基于跳跃游戏的基础

得到的数组dis为，经过第i个值，可以跳到的最远距离

使用这个来一波贪心，每次跳到当前位置的i可以跳到的最大位置

因为dis[i]一定比dis[i - 1]跳得远，这是我们计算时设计的性质

# 乘积为正的最长子数组：与和最大的子数组那道题有点像

每个节点，记录两个状态，以第i个元素结尾的，连乘为付的最大长度和连乘为正的最大长度dp[i][0]/dp[i][1]

dp[i]和dp[i + 1]

如果nums[i+1]大于0，那么，dp[i + 1][1] = dp[i][1] + 1;

    若，dp[i][0]不为0，也就是说，以i结尾，存在乘积为复数的子字符串，就dp[i + 1][0] = dp[i][0] + 1;

    若dp[i][0]为0，不存在以i结尾，存在乘积为复数的子字符串，乘以一个正数，结果不会变成复数，dp[i + 1][0] = dp[i][0] = 0，不用变；

如果nums[i+1]小于0，那么，dp[i + 1][0] = dp[i][1] + 1;不管有没有以i结尾的，乘积为正的子串，+1总是合理的

    若，dp[i][0]不为0，也就是说，以i结尾，存在乘积为负数的子字符串，就dp[i + 1][1] = dp[i][0] + 1;

    若dp[i][0]为0，不存在以i结尾，存在乘积为负数的子字符串，乘以一个负数，结果不会变成复数，dp[i + 1][0] = dp[i][0] = 0，不用变；

如果ums[i+1]等于0，那么，两个都置为0

所有dp[:][1]的最大值就是答案

# 环形子数组和最大和

去掉环形这个要求，按照非环形的来做一下得到，以最后一个元素结尾的最大子数组和的值

并记录这个最大子数组的起点

然后判断

**把数组弄成一个环，切成两半，我们希望其中和较大的一半最大，两个思路，一个计算大的一半的最大值；或者计算和小的一半的最小值，这两个等价**

**如果符合要求的数组不跨越首尾，那么就按照正常的非环状的子数组和最大，求它的最大值**

**如果数组跨越首尾，说明，数组和最小的子数组不跨域首尾，我们计算这个东西**

计算，不考虑环形的最大子数组和，与不考虑环形的最小子数组和

结果为， 不考虑环形的最大子数组和 与sum- 不考虑环形的最小子数组和中 较大的一个

注意，如果不考虑环形的最小子数组等于sum，这种情况直接输出不考虑环形的最大子数组和，因为这要求一个元素都不选

# 乘积最大子数组

和乘积为正的解法一样

需要记录，以当前元素为末尾的子数组中，乘积最正的和乘积最负的

# 最佳观光组合

**重点在于看出这个公式的变形**

查看算式，可以变形为：va[i] + i +(va[j] - j)

后半部分对每个位置来说是常量，va[i] + i也不怎么随着位置的变动而改变

更新一个，相对于当前位置的最佳前置景点

当当前位置从k-1 变到 k的时候，va[i] + i可能会变为，va[k-1] + k-1

# 买卖股票的最佳时机

获利为p[j] - p[i]

对于每个p【j】来讲，他是确定的，因此我们想要找到一个最低的p[i]

因此可以从前向后遍历，维护一个最低的p，由此计算每一天可以得到的最高收益

从j天到j+1天后，最低的p可能变成第j天的价格

# 买卖股票的最佳实际2

**这里关心的是我手上有的金额的最大值，不是我盈利多少**

因此每天，我们维护两个值，是我们手头上有的最大的金额。一个是，买入了股票，一个是卖出了股票，也就是持有和不持有股票，记录在每一种情况下，手头上的最大金额

他和前一天的状态有关

当天持有股票的最大金额，是前一天持有股票和前天不持有股票，但是今天持有股票，这两个中的最大值

当天不持有股票的最大金额，是前一天不持有股票和前一天持有股票，但是，今天不持有股票，这两个中的最大值

# 买卖股票的最佳时机喊冰冻期

**和2差不多吧，但是要多考虑前前一天的情况，因为，存在一天的冰冻期**

如果昨天卖出股票，今天就不能买入股票，

或者有三个状态？

今天不持有但不是今天卖出，今天持有，今天不持有并且今天卖出

分别是0，1，2

对于0， 它的值是如下元素的最大值：前天的0， 昨天的0， 昨天的2，前天的2（或许可以简化，但没必要了）

对于1，它的值是如下元素的最大值：前天的1，昨天的1，昨天的0 - price， 前天的1 - price

对于2， 它的值是如下元素的最大值： 昨天的1 + price， 前天的1 + price

最后一天的0/2中的较大值是结果

# 包含手续费的买卖股票最佳时机

和2 一样，但是加上手续费的损耗

# 单词拆分

动态规划？

dp[i]表示，前i个字符是否可以拆分

假设j < i,那么ruguo dp【j】可以拆分，并且s【j+1,i】可以拆分，那么dp[i]是可以拆分的

我们可以复用dp[j]的状态了

同时，还注意到，如果，dp[i]可以拆分，那么它之前一定有个j，s[j + 1, i]正好是**一个**单词,因此我们只要在字典中搜索s[j + 1, i]就好了


# 接雨水

hard，过了

# 等差数列划分

维护一个以当前元素为末尾的最长等差子数组的长度，以及他和上一个元素的差，dp是在它之前的这种等差数列的个数

对于状态转移，如果当前元素和上一个元素的差等于上一个和上上一个的差，那么，最长等差子数组的长度加一，dp是上一个的dp+max（当前子数组长度 - 3 + 1， 0）

# 解码方法

非常标砖的动态规划

dpi是以第i个元素为结尾时，解码方法的个数

他和dp i-1的关系是，

如果s i为0，

s[i-1]和s[i]合法

dpi = dp[i-2]

s[i-1]和s[i]不合法

return 0；

如果si不为0

s[i-1]和s[i]合法

dpi = dp[i-1] + dp[i-2]

s[i-1]和s[i]不合法

dpi = dp[i-1]

**初始的dp0，dp1计算要小心啊，改了很长时间**

# 三角形最小路径和

每个第i个节点，可以从上一层的i-1和i个节点过来

取较小的一个

输出最后一行的最小值

也可以从底部到顶部，这样最后不需要判断

# 丑数2

每一个丑数乘以2，乘以3，乘以5，肯定还是丑数

因此，我们要对每个丑数乘2，乘3。乘5的结果进行排序，变成有小到大的有序排列

简单的想法是，每个丑数乘2 < 每个丑数*3 < 每个丑数 * 5

但是，不同丑数之间的怎么排列，按照基数的大小排列吗，不行啊，可能 大的丑数 * 2 < 小的丑数 * 5（3，2）

**官方解法的思路是： 将每个元素的乘2， 乘3， 乘5分开**

相当于有三个序列，分别是丑数序列（每个元素）乘2得到的序列，丑数序列乘3得到的序列，丑数乘5序列，我们用三个指针，分别指向这三个序列中的位置，然后合并这三个序列

简单的比较这三个指针指向的值，取最小的加入丑数序列，然后后移那个指针，指向丑数乘n序列的下一个元素，然后进行下一次比较

**还有一个很重要的点，可能会出现两个指针指向的值相同，比如3 * 2和2 * 3,这时候两个指针都要跳过**

这里和一般的合并三个序列不同的是是，丑数序列会不断变长，乘n序列也会实际上变长，但这个点没什么用

# 不同的二叉搜索树

简单，长度相同的序列（比如1 - 5和5 - 9），他们的二叉搜索树的种类是一样的

如果长度为n的序列的搜索树的种类为fn

对于长度为n+1的序列，它可以分为，左子树长度为n，右子树长度为0；左子树长度为n-1，右子树长度为1... ；左子树长度为0，右子树长度为n

可以有如下的转移公式

有 fn+1 = (fn * f0) + (fn - 1) * (f1) + ... + (f1 * fn-1) + (f0 * fn);

# 矩阵区域和

计算二维前缀和sum

answer【i,j】 = sum[i + k, j + k] - sum[i  - k, j + k] - sum[i + k, j - k] + sum[i - k, j - k]

# 不同路径2

有障碍物

1. 如果当前格子有障碍物，到这里的方法为0

2. 不然，等于到上一个格子和左一个格子的方法只和

3. 终点在于初始化

    初始一个-1行的last，它的长度为n+1， last【1】= 1;

    这样，第0行的元素，若没有障碍物，路径数全部为1

    
# 最长回文串

用dp[ij]代表从i到j是否是回文串，

dp[i -1, j + 1]和sp[ij]有关

所有的dp[ii]均为1，还要设置一个dp[-1-1],以应对aa这种回文串

# 最长递增子序列

sp[i]为以第i个元素结尾的子序列中最长的长度

它和前面的元素有关， 在nums【i]之前的元素里，小于nums[i]的元素nums[j]，对应的dp[j] + 1 就是dp[i]

# 摆动序列

和上面的类似，但是dp[i][0]是作为峰谷，dp[i][1]作为峰顶

# 判断子序列

# 最长公共子序列

DP：

二维DP问题：创建m+1和n+ 1的dp矩阵

dp[i][j]代表，text1（0：i）和text2(0:j)之间的最长公共子序列长度

子问题，text1（0：i）和text2(0:j)之间的最长公共子序列长度

转移公式：

如果text1[i] == text2[j]，那么，dp[i][j] = dp[i - 1][j - 1] + 1,很好理解

如果text1[i] ！= text2[j]，那么，dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])：也好理解

边界条件：

text1（0：0）和text2(0:j)公共长度为0

**直觉上，他和最大正方形面积很像**

# 最大正方形面积

DP：

子问题，以每个点作为右下角的正方形的最大的面积

转移公式：

该点为0：0

该点为1：上方一个点，左方一个点，左上一个点中的最小值 + 1；

# 编辑距离

复杂。。

# 零钱兑换

标准dp

dp【i】记录，兑换i元需要的最小个数

dp[i] 和 dp[i - coins[0]],... dp[i - coins[k]]有关

外层循环为i，内层循环为coin

**注意，如果dp[i - coins[0]]为-1，不能用它来更新**

# 零钱兑换2

兑换方案数量：有点不一样了，

不能直接加，会有重复的，要把重复的去了

外层遍历coin，内层遍历dp：这样的后果是，每次新添加的方案，都是以当前正在遍历的coin作为结尾的，不会出现上没有遍历过的硬币，可以不重复

就是交换了一下内外侧循环

**这个问题和爬楼梯很像，但是爬楼梯是求排列方式个数，这个试求组合方式个数**

这是一个背包问题，不是楼梯问题，这里我们关心硬币有没有被用到

可以将子问题定义为，使用前k个硬币，可以构成金额的方法数



https://leetcode.cn/problems/coin-change-ii/solution/ling-qian-dui-huan-iihe-pa-lou-ti-wen-ti-dao-di-yo/

# 背包问题

dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值

如果i不放进去，那么dp[i][j] = dp[i - 1][j]

如果i放进去dp[i][j] = dp[i - 1][j - w_i] + value_i
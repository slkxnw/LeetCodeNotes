# 删除重复项

cnt记录有多少个非重复项，并且指明，有新的非重复项，应该插在哪里

当当前元素和上一个元素不一样，就将元素数组cnt的位置改成当前元素，然后cnt++

注意，数组长度必须大于1；并且，第一个元素要在循环前添加

# 买卖股票最佳时机

这是一个NP问题，实际上，只能用贪心算法

今天的价格比明天低，我就买入，保证至少有得赚，如果后天价格比明天高，就持有，后天比明天低，就明天卖出

总结：高抛低吸（今天相对于明天）

# 旋转数组

1. 新建一个数组，完成这个旋转

2. 先把全部数组翻转，再翻转前k个，再翻转后（n-k）个

    使用reverse（vector, start, end）

3. 环形替换

    x->x+k->x+k+k....
    
    注意：数组当长度是k的倍数时，会陷入循环，需要一个方法跳出循环

# 找出重复元素

使用哈希表记录出现次数

# 找出不重复元素

1. 使用哈希表，记录出现次数，出现两次后就删掉，最后只剩下一个出现一次的元素

2. 如何使用常量空间完成这个任务？

    我使用了删掉出现两次的东西

    使用异或运算：一连串的异或运算后，两个相同的元素会被消掉，最后只剩下出现过一次的元素

# 两个元素的交集

1. 使用哈希表，记录第一个数组出现的元素及次数，然后以第二个数组中的元素作为key查询结果

这个时间On，空间最坏On

2. 使用排序，然后使用两个指针指向这两个数组的开头，然后从前向后遍历两个数组，知道一个指针到达末尾

    如果指向的元素一致，就双双后移，不一致，指向元素较小的指针后移

    时间Onlogn,空间O1

# +1

1. 新建res==digits，从最后一位开始操作

    首先+1，如果结果小于10， 就退出循环，如果结果为10，就对上一位操作

    退出循环后，如果第一个元素为0，就在最后补上0，并将第一位改为1:它对应的情况是9999..99 + 1

# 移动0

1. 和删除重复项一个思路，从前到后遍历，cur记录出现非零数的数量，也是下一个非零数出现后，应该插入的位置，因为有0，cur一定小于等于当前遍历到的位置

# 有效的数独

1. 使用哈希表，记录每行/每列/每个方块出现过的元素，看是否有重复

2. 元素的雷翔是限制的，可以使用27*9的数组代替哈希表，但是，注意，将board的元素变为数组时，**不要减去0，减去1**，数独的范围是1-9

# 旋转矩阵

1. 先上下交换，再沿着主对角线交换
    主对角线交换时，直接swap(m[i][j], m[j][i])

# 中级算法

# 三数之和

排序，然后，确定第一个数numi，在numi的右边选定numj和numk，他们的和为0

如果，和大于0，就numk左移，否则numj右移

**细节太多了**

1. 关于i的范围

    从0到nums.size() - 2

    当nums[i]>0,break

    当nums[i] == nums[i - 1]，略过

2. 关于jk

    j初值为i+1， k初值为nums.size() - 1

    一旦有了一组数，首先把j++， k--

    **然后需要去掉重复的值**

    条件为 j < k，并且
    nums[j] == nums[j - 1]
    nums[k] == nums[k + 1]

# 原地置零

记录0出现的行数和列数，需要m+n空间

常量空间方案

使用第一行和第一列，记录除他们自己之外的行列是否需要置零，，再使用额外的两个量记录他们需不需要置零

# 字母异位词分组

排序每个单词，异位词排序后有相同的排布，一个哈希表记录每个排布对应vector的位置

# 最长无重复子串

双指针，超出出现重复值后，以第一个重复值为起点再次构建新的子串

**注意，最后的一个子串不会在循环中比较，因此要在循环外，比较这个子串**

## 只出现一次的数字

使用异或运算^

a^a = 0

a^0 = a

全部^一遍剩下的就是出现一次的数字

## 多数元素

空间复杂度为O1

boyer-moore算法

其他方法：

1. 哈希表

2. 排序

    n/2个元素一定是多数元素

## 三数之和

## 颜色分类

两次快排，首先将小于2 的元素都挪到2的左边

然后将小于1的元素挪到1  的左边

## 合并区间

将每个区间分为入口id/出口id，然后对他们排序，id相同时，按照先入口在出口的顺序进行排序

遍历这些id

入口时，cnt++；
出口时，cnt--

没有操作的时候，如果cnt==0，说明当前的会是入口，

操作后，cnt==0，说明当前是出口

官方解法：

排序数组，然后遍历

如果merged为空，就把当前intval放入merged

如果当前intval的左端点zaimerged最后一个区间内，就更新右端点为当前端点和intval右端点的最大值

这个设计可以不用考虑什么时候把区间加到merged

## 螺旋矩阵

模拟方法，左下右上，按照这个顺序模拟一圈，将第k圈模拟完

注意index

## 搜索二维数组

减少搜索空间，从右上开始，如果当前元素大于tgt，就左移，如果当前元素小于tgt，就下移，直到超出边界

也可以从左下开始

## 无重叠区间

dp

将问题转换：有前i的子区间是=时，可以选取最多的子区间，他们不重叠

对于dp[i]

可以选择要他，但是就不能要它覆盖区间之内的其他区间，就是在它覆盖区间左边的第一个区间j， 的dp【j】+ 1

可以不要他，最大值就是dp[i - 1]

比较这两个，选最大的

就是打家劫舍

贪心算法：

选取的区间，应该是和之前的区间不重合，并且，右端点尽可能小的区间，贪心

将数组按照右端点从小到达排列

第一个肯定要选上，此时的r就是它的右端点

然后遍历，当一个数组的左端点大于等于当前的r的时候，就将这个数组选上，并更新r

## 递增的三元子序列

On方法：类似于叠积木

将可行的small和mid都叠起来，找到big后，从mid 和small中各抽出一个就能组成三元组

## 除自身意外的乘积

不能使用除法

题目理解错了：是不乘以自身的数组乘积

O1空间

使用两个三角矩阵

看一下答案，很有道理，优雅，以当前元素为分界线，将在两个循环中处理ans【i】的前半部分连乘和后半部分连乘

每个循环中，连乘的结果可以复用

## 和为k的连续子数组个数

dp，

dp[i]代表，前i个元素组成的子数组中，和为k的连续子数组个数

维护一个滑动窗口，它的右边界为nums[i]，左边界为是其和为K的左边界

如果nums[i] == k, dp[i] = dp[i - 1] + 1;

如果nums【i] > k, dp[i] = dp[i - 1],同时要移动这个窗口

如果nums[i] < k, 就调整窗口左边界，看能否弄成结果为K

问题是，可能会有很多个窗口满足这个条件，所以说，用前缀和？

使用哈希表记录每个前缀和出现的位置，位置肯定是有序排列的，然后找到第一个满组要求的位置，前面的都可以

**想麻烦了**

计算前缀和，使用哈希表记录每种前缀和出现的次数

找出当前的sum-k的出现了几次，他们和当前的前缀和可以构成答案

注意：

1. 前缀和为0的次数默认为1，就是一个元素都不选

2. 线统计次数，再把当前位置的前缀和做统计


